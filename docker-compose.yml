# Startup order: postgres → unleash-server → product-service → order-service
# All services share a dedicated bridge network (app-network) and use service names as hostnames.
services:
  # PostgreSQL - required by Unleash server for persistent storage.
  # Uses environment variables for credentials and a named volume for data persistence.
  postgres:
    image: postgres:15
    ports:
      - "5432:5432"
    environment:
      POSTGRES_USER: unleash
      POSTGRES_PASSWORD: unleash
      POSTGRES_DB: unleash
    # Named volume mount: connects the 'postgres-data' volume (declared at bottom of file)
    # to the container's data directory. Without this, DB data is lost on container removal.
    volumes:
      - postgres-data:/var/lib/postgresql/data
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "pg_isready", "-U", "unleash"]
      interval: 10s
      timeout: 5s
      retries: 3

  # Unleash Server - feature flag management UI and API.
  # Waits for postgres to be healthy before starting ('depends_on' + 'condition').
  unleash-server:
    image: unleashorg/unleash-server
    ports:
      - "4242:4242"
    environment:
      DATABASE_URL: postgres://unleash:unleash@postgres:5432/unleash
      DATABASE_SSL: "false"
      # Admin token for init-flags.sh script (Unleash Admin API).
      INIT_ADMIN_API_TOKENS: "*:*.unleash-insecure-admin-api-token"
      # Client token consumed by product-service and order-service SDKs.
      # The official default API token
      INIT_CLIENT_API_TOKENS: "default:development.unleash-insecure-api-token"
    depends_on:
      postgres:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:4242/health"]
      interval: 10s
      timeout: 5s
      retries: 5

  product-service:
    build: ./product-service
    ports:
      - "8081:8081"
    environment:
      - UNLEASH_API_URL=http://unleash-server:4242/api
      - UNLEASH_API_TOKEN=default:development.unleash-insecure-api-token
      - UNLEASH_APP_NAME=product-service
    depends_on:
      unleash-server:
        condition: service_healthy
    networks:
      - app-network
    # Compose periodically checks the container by calling Spring Boot Actuator's '/actuator/health' endpoint.
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/actuator/health"]
      interval: 10s
      timeout: 5s # 5s per check
      retries: 3 # 3 failures → container marked unhealthy

  order-service:
    build: ./order-service
    ports:
      - "8082:8082"
    environment:
      - SERVER_PRODUCT_URL=http://product-service:8081
      - UNLEASH_API_URL=http://unleash-server:4242/api
      - UNLEASH_API_TOKEN=default:development.unleash-insecure-api-token
      - UNLEASH_APP_NAME=order-service
    # Order Service starts only after Unleash and Product Service are both "healthy".
    # YAML map key order has no semantic meaning; Docker checks both conditions simultaneously (AND).
    # reference: https://docs.docker.com/compose/how-tos/startup-order/
    depends_on:
      unleash-server:
        condition: service_healthy
      product-service:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8082/actuator/health"]
      interval: 10s
      timeout: 5s
      retries: 3

# Dedicated bridge network - all services communicate using service names as hostnames.
networks:
  app-network:
    driver: bridge

# Named volume declaration - tells Docker to create a persistent storage space called 'postgres-data'.
# The postgres service mounts (connects) this volume to /var/lib/postgresql/data above.
# Empty value means Docker uses the default local driver. No extra options needed.
volumes:
  postgres-data:
